package {{.p}}

import "fmt"

// {{.T}} keeps {{.K}} in order by {{.V}}[{{.K}}[i]] value.
//
// It assumes a relatively static set in {{.K}} that you want to keep sorted as
// their values in {{.V}} change. You first add all the keys using Add and then
// use Move to change the values. As you do so, {{.K}} will be kept in order.
//
// Note that the values of the keys are simply stored in a slice and not a map,
// so wildly varying min/max keys will use a lot of memory. It should be easy
// to modify to use a map if desired though; for my use, a slice was fine and
// much faster than a map.
//
// The RandIntn function may be set to randomize key locations whose values are
// the same. Even if RandIntn is nil, the order of keys whose values are the
// same is not guaranteed to be in any particular order (think like Go's map
// key order, no guarantees).
//
// I know it's a weird "key/value randomization bag" or something and probably
// not generally useful, but I had to create it for my
// github.com/gholt/ring/lowring package where I needed to sort nodes and
// groups by their desires, so here it is.
//
// This code will copy memory quite a bit and can probably be improved with
// scanning for value runs and swapping. Of course, if there are few runs,
// swapping "by hand" will probably be slower than just calling copy. Not sure
// yet, just haven't gotten that far. Oh, and another note if you (or future
// me) decides to try this optimization, you'll have to swap before applying
// the RandIntn, and then use that to swap a second time.
type {{.T}} struct {
    {{.K}} []{{.k}}
    {{.V}} []{{.v}}
    RandIntn func(int) int
}

func {{.new}}(cap int, randIntn func(int) int) *{{.T}} {
    return &{{.T}}{
        {{.K}}: make([]{{.k}}, 0, cap),
        {{.V}}: make([]{{.v}}, 0, cap),
        RandIntn: randIntn,
    }
}

func (x *{{.T}}) Add(key {{.k}}, value {{.v}}) {
    ln := len(x.{{.V}})
    if int(key) < ln {
        x.Move(key, value)
        return
    }
    if int(key) == ln {
        x.{{.V}} = append(x.{{.V}}, value)
    } else {
        x.{{.V}} = append(x.{{.V}}, make([]{{.v}}, int(key)-ln+1)...)
        x.{{.V}}[key] = value
    }
    right := 0
    hi := len(x.{{.K}})
    for right < hi {
        mid := (right + hi) / 2
        if value > x.{{.V}}[x.{{.K}}[mid]] {
            hi = mid
        } else {
            right = mid + 1
        }
    }
    if x.RandIntn != nil {
        left := 0
        hi = len(x.{{.K}})
        for left < hi {
            mid := (left + hi) / 2
            if x.{{.V}}[x.{{.K}}[mid]] > value {
                left = mid + 1
            } else {
                hi = mid
            }
        }
        if right-left > 2 {
            right = right - x.RandIntn(right-left)
        }
    }
    x.{{.K}} = append(x.{{.K}}, 0)
    copy(x.{{.K}}[right+1:], x.{{.K}}[right:])
    x.{{.K}}[right] = key
}

func (x *{{.T}}) Move(key {{.k}}, value {{.v}}) {
    var oldPosition int
    oldValue := x.{{.V}}[key]
    right := 0
    hi := len(x.{{.K}})
    for right < hi {
        mid := (right + hi) / 2
        if oldValue > x.{{.V}}[x.{{.K}}[mid]] {
            hi = mid
        } else {
            right = mid + 1
        }
    }
    right--
    if x.{{.K}}[right] == key {
        oldPosition = right
    } else {
        left := 0
        hi = len(x.{{.K}})
        for left < hi {
            mid := (left + hi) / 2
            if x.{{.V}}[x.{{.K}}[mid]] > oldValue {
                left = mid + 1
            } else {
                hi = mid
            }
        }
        if x.{{.K}}[left] == key {
            oldPosition = left
        } else {
            for oldPosition = left + 1; x.{{.K}}[oldPosition] != key && oldPosition < right; oldPosition++ {
            }
        }
    }
    right = 0
    hi = len(x.{{.K}})
    for right < hi {
        mid := (right + hi) / 2
        if value > x.{{.V}}[x.{{.K}}[mid]] {
            hi = mid
        } else {
            right = mid + 1
        }
    }
    if x.RandIntn != nil {
        left := 0
        hi = len(x.{{.K}})
        for left < hi {
            mid := (left + hi) / 2
            if x.{{.V}}[x.{{.K}}[mid]] > value {
                left = mid + 1
            } else {
                hi = mid
            }
        }
        if right-left > 2 {
            right = right - x.RandIntn(right-left)
        }
    }
    if right < oldPosition {
        copy(x.{{.K}}[right+1:], x.{{.K}}[right:oldPosition])
        x.{{.K}}[right] = key
    } else if oldPosition < right {
        copy(x.{{.K}}[oldPosition:], x.{{.K}}[oldPosition+1:right])
        x.{{.K}}[right-1] = key
    }
    x.{{.V}}[key] = value
}

func (x *{{.T}}) String() string {
    s := "["
    for i, key := range x.{{.K}} {
        if i == 0 {
            s += fmt.Sprintf("%d:%d", key, x.{{.V}}[key])
        } else {
            s += fmt.Sprintf(" %d:%d", key, x.{{.V}}[key])
        }
    }
    return s + "]"
}
